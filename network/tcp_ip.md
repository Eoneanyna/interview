# TCP/IP

TCP/IP传输协议是严格来说是一个四层的体系结构，应用层、传输层、网络层和数据链路层都包含其中。

## 网络层上的攻击

### ARP欺骗

ARP（地址解析协议）是根据IP地址获取物理地址的一个TCP/IP协议。通常情况下，在IP数据包发送过程中会存在一个子网或者多个子网主机利用网络级别第一层，而ARP则充当源主机第一个查询工具，在未找到IP地址相对应的物理地址时，将主机和IP地址相关的物理地址信息发送给主机。与此同时，源主机将包括自身IP地址和ARP检测的应答发送给目的主机。如果ARP识别链接错误，这样的话ARP直接应用可疑信息，那么可疑信息就会很容易进入目标主机当中。ARP协议没有状态，不管有没有收到请求，主机会将任何受到的ARP相应自动缓存。如果信息中带有病毒，采用ARP欺骗就会导致网络信息安全泄露。因此，在ARP识别环节，应加大保护，建立更多的识别关卡，不能只简单通过IP名进行识别，还需充分参考IP相关性质等。 [3]

### ICMP欺骗

ICMP协议也是因特网控制报文协议，主要用在主机与路由器之间进行控制信息传递。通过这一协议可对网络是否通畅、主机是否可达、路由是否可用等信息进行控制。一旦出现差错，数据包会利用主机进行即时发送，并自动返回描述错误的信息。该协议在网络安全当中是十分重要的协议。但由于自身特点的原因，其极易受到入侵，通常而言，目标主机在长期发送大量ICMP数据包的情况下，会造成目标主机占用大量CPU资源，最终造成系统瘫痪。 [3]

## 传输层上的攻击

在传输层还存在网络安全问题。如在网络安全领域中，IP欺骗就是隐藏自己的有效手段，主要是通过将自身IP地址进行伪造，并向目标主机发送恶意的请求，攻击主机，而主机却因为IP地址被隐藏而无法准确确认攻击源。或者通过获取目标主机信任而趁机窃取相关的机密信息。在DOS攻击中往往会使用IP欺骗，这是因为数据包地址来源较广泛，无法进行有效过滤，从而使IP基本防御的有效性大幅度下降。此外，在ICMP传输通道，由于ICMP是IP层的组成部分之一，在IP软件中任何端口向ICMP发送一个PING文件，借此用作申请，申请文件传输是否被允许，而ICMP会做出应答，这一命令可检测消息的合法性。所有申请传输的数据基本上传输层都会同意，造成这一情况的原因主要是PING软件编程无法智能识别出恶意信息，一般网络安全防护系统与防火墙会自动默认PING存在，从而忽视其可能带来的安全风险。 [3]

## 应用层上的攻击

对于因特网而言，IP地址与域名均是一一对应的，这两者之间的转换工作，被称为域名解析。而DNS就是域名解析的服务器。DNS欺骗指的是攻击方冒充域名服务器的行为，使用DNS欺骗能将错误DNS信息提供给目标主机。所以说，通过DNS欺骗可误导用户进入非法服务器，让用户相信诈骗IP。另外，PTP网络上接口接受到不属于主机的数据，这也是应用层存在的安全问题，一些木马病毒可趁机入侵，造成数据泄露，从而引发网络安全问题。

# 常见面试题

### 1.**简述OSI模型**

### 2.简述三次握手和四次挥手

### 3.为什么是三次握手而不是两次握手？

- 因为如果客户端第一次发送的SYN报文因为网络问题而迟迟没有到达服务端，此时客户端会因为超时而重新发送一个新的SYN报文，此时上一个SYN报文在客户端就会失效，如果这里只采用两次握手，会因为客户端第二次发送SYN后，第一次发送的SYN又成功到达服务端，这时就会建立两个连接，产生问题。

### 4.为什么连接的时候是三次握手，关闭的时候却是四次握手？

- 因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET（由于 TCP 的半关闭（half-close）特性，TCP 提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力。）所以只能先回复一个ACK报文，告诉Client端，"你发的FIN报文我收到了"。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。
- 便于理解的例子：A 和 B 打电话，通话即将结束后，A 说 “我没啥要说的了”，B 回答 “我知道了”，于是 A 向 B 的连接释放了。但是 B 可能还会有要说的话，于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”，A 回答“知道了”，于是 B 向 A 的连接释放了，这样整个通话就结束了。

### 5.在挥手报文发生丢失时会发生什么？

- **第一次挥手丢失**
  当客户端调用close函数后，就会向服务端发送FIN报文，试图与服务端断开联系，此时客户端进入FIN_WAIT_1状态。

  如果客户端一直收不到ack应答报文的话，就会触发超时重传机制，最大重传次数由tcp_orphan_retries参数决定。当超过指定次数时，就不再发送报文，直接进入close状态

- **第二次挥手丢失**
  当接受到客户端的FIN报文，就会先回应一个ack报文，此时服务端进入close_wait状态。

  当ack报文丢失时，ack是不会重传的。服务端的ack报文丢失了，客户端就会触发超时重传，直到收到ack报文或则到达超时重传次数

- **第三次挥手丢失**
  当服务端接收到客户端的fin报文时，内核会自动回复ack应答报文，然后处于CLOSE_WAIT状态，他必须等待应用进程调用close函数关闭连接。

  调用close函数后，内核就会发出FIN报文，进入LAST_ACK状态，等待客户端返回ack来确认关闭连接。

  如果服务端没有收到ack，则会跟客户端重传FIN报文一样，重新发送。

- **第四次挥手丢失**
  当客户端接收到服务端发来的FIN报文后，就会回应ack应答报文，进入TIME_WAIT状态。

  服务端没有收到ack报文之前，还是处于LAST_ACK状态

  如果服务端没有收到ack报文的话，服务端就会重发FIN报文，重发次数仍然由tcp_orphan_retries参数控制

  

### 6.**如果已经建立了连接，但是另一端突然出现故障，会发生什么？？？**

TCP有一个保活机制，当一端时间相互直接没有发送数据时，就会触发保活机制。即每隔一段时间都发送一次探测报文给对方，如果几次都不回应的话，就会认为对方已经死亡了，那么就会断开连接。
如果需要使用保活机制，那么需要在soket接口设置so_keepliive才能生效，如果没有设置，则不可以生效
TCP的检测时间有点长，我们可以在应用层实现一个心跳机制。
web服务一般都会提供time_keeplive参数，用来指定http长连接超时时间。